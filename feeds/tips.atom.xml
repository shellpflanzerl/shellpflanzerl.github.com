<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>shellpflanzerl</title><link href="https://shellpflanzerl.github.io/" rel="alternate"></link><link href="https://shellpflanzerl.github.io/feeds/tips.atom.xml" rel="self"></link><id>https://shellpflanzerl.github.io/</id><updated>2015-01-12T13:21:00+01:00</updated><entry><title>Use a Yubikey to mount encrpyted LUKS volumes</title><link href="https://shellpflanzerl.github.io/use-a-yubikey-to-mount-encrpyted-luks-volumes.html" rel="alternate"></link><updated>2015-01-12T13:21:00+01:00</updated><author><name>Martin Zehetmayer</name></author><id>tag:shellpflanzerl.github.io,2015-01-12:use-a-yubikey-to-mount-encrpyted-luks-volumes.html</id><summary type="html">&lt;p&gt;A few days ago I got a Yubikey Nano for testing. After a while I found a project where
I could use the help of a small keystorage device like the Yubikey. &lt;/p&gt;
&lt;p&gt;I have a LUKS encrypted partition on my NAS which is not mounted automatically during
bootup. To mount it I log in to the system and issue the 'cryptsetup luksOpen' and mount commands
manually. This is fine with me but what if other people - like my wife - needs to access
the encrypted data? The password (which exceeds more then 30 letters) is to hard to remember
for someone who does not use it everyday. &lt;/p&gt;
&lt;p&gt;A possible solution is the use of a hardware token which delivers a valid passphrase for the
encrypted device. The Yubikey emulates an USB HID Device and has two configuration slots which
can be programmed to fit different usecases. It comes preconfigured with Yubico OTP on slot 1
(128 bit AES onetime passwords, see https://www.yubico.com/products/services-software/personalization-tools/yubikey-otp/) and a secondary empty slot. &lt;/p&gt;
&lt;p&gt;For the second slot we use the Challenge-Response Configuration. It takes a challenge block of 1-64 bytes and calculates a HMAC-SHA1 on this using the 160-bit secret stored in the Yubikey. The resulting 160-bit hash is sent back as a response which is used as passphrase for the LUKS device. &lt;/p&gt;
&lt;p&gt;The configuration is done with the yubikey personalisation software (GUI version), which can be downloaded from the yubiko website.&lt;/p&gt;
&lt;p&gt;To get everything running on my F21 server there are a few steps to take: &lt;/p&gt;
&lt;p&gt;First of all we need the software:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;yum -y install ykpers
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then we can insert the Yubikey in a USB slot and test it: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@nas [0] ~ # ykinfo -a
serial: XXXXXXXX
serial_hex: XXXXXXX
serial_modhex: XXXXXXX
version: 2.4.2
touch_level: 1790
programming_sequence: 3
slot1_status: 1
slot2_status: 1
vendor_id: 1050
product_id: 10
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Yubikey is now ready. Now we are testing the challenge-response configuration: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@nas [130] ~ # ykchalresp -2 &amp;#39;this is a test&amp;#39;
bf2e98ba2ee43ab52dc5e32545bae8b11cb06f19
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We got a response which will be used as passphrase for LUKS. But we need a better challenge for
this simple text is too easy to guess. Possible methods are the use of /dev/urandom (for example
dd if=/dev/urandom bs=1 count=40 2&amp;gt;/dev/null| base64). 
To mount the volume with this key we need to enter it to a free key slot in the LUKS device.
Normally only slot 0 has a key, but just to be sure we check that: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@nas [0] ~ # cryptsetup luksDump /dev/data/private | grep DISABLED
Key Slot 1: DISABLED
Key Slot 2: DISABLED
Key Slot 3: DISABLED
Key Slot 4: DISABLED
Key Slot 5: DISABLED
Key Slot 6: DISABLED
Key Slot 7: DISABLED
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We add the key:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cryptsetup luksAddKey --key-slot 1 /dev/data/private
Enter any existing passphrase:
key slot 0 unlocked.
Enter new passphrase for key slot:
Verify passphrase:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When all worked we have now a new key in keyslot 1:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@nas [0] ~ # cryptsetup luksDump /dev/data/private | grep DISABLED
Key Slot 2: DISABLED
Key Slot 3: DISABLED
Key Slot 4: DISABLED
Key Slot 5: DISABLED
Key Slot 6: DISABLED
Key Slot 7: DISABLED
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Key Slot 1 is now not DISABLED, so we have a key in it. To get all this work together
we can write a Script which gets the password from the Yubikey, unlocks the LUKS device
and mount it: &lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;# random string as challenge! CHANGE THIS FOR YOUR NEED!&lt;/span&gt;
&lt;span class="nv"&gt;challenge&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;yitwoydCaichewzyagudyanwikjeefJajIrKouQuizdu&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;pass&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;ykchalresp -2 &lt;span class="nv"&gt;$challenge&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$pass&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; cryptsetup luksOpen /dev/data/private myprivatedata
mount /dev/mapper/myprivatedata /my_private_data
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now we have a fully functional Yubikey configured to mount LUKS devices.
The next step to automate the mount are to call this script when the Yubikey is inserted - 
in Part 2 of this article (coming soon!) &lt;/p&gt;</summary><category term="Linux"></category><category term="Security"></category></entry><entry><title>Upgrade to Fedora 21, the dnf way</title><link href="https://shellpflanzerl.github.io/upgrade-to-fedora-21-the-dnf-way.html" rel="alternate"></link><updated>2015-01-05T22:00:00+01:00</updated><author><name>Georg Vogetseder</name></author><id>tag:shellpflanzerl.github.io,2015-01-05:upgrade-to-fedora-21-the-dnf-way.html</id><summary type="html">&lt;p&gt;My fleet of Fedoras is always updated using yum directly. I presume that
&lt;code&gt;fedup&lt;/code&gt; works well for most use cases, but I think using the package manager directly,
as with pacman or apt-get is the golden way to upgrading. The last really
hard Fedora upgrade this way was the Fedora 17 Upgrade, where &lt;code&gt;/bin&lt;/code&gt; and
&lt;code&gt;/usr/bin&lt;/code&gt; got merged. It was possible, but there was a lot of ugliness
involved when using 3rd-party RPMs. The Fedora 21 upgrade contains nothing nasty in
this department.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://fedoraproject.org/wiki/Upgrading_Fedora_using_yum#Fedora_20_-.3E_Fedora_21"&gt;The official Wiki page&lt;/a&gt;
contains no warnings, just the usual RPM-Key import and a notice on choosing a
flavor. A &lt;code&gt;touch /.autorelabel&lt;/code&gt; should fix SELinux Problems.&lt;/p&gt;
&lt;p&gt;To spice things up, I thought to use
&lt;a href="https://github.com/rpm-software-management/dnf"&gt;&lt;code&gt;dnf&lt;/code&gt;&lt;/a&gt; - the new package
manager in Fedora for the upgrade. It utilizes &lt;code&gt;libsolv&lt;/code&gt; from openSUSE for
dependency resolution and should work better than yum in this respect.&lt;/p&gt;
&lt;p&gt;And it totally worked for me. Without a single problem, just by replacing the yum commands from
the wiki with dnf. Cool stuff.&lt;/p&gt;</summary></entry><entry><title>Upgrade to Fedora 21</title><link href="https://shellpflanzerl.github.io/upgrade-to-fedora-21.html" rel="alternate"></link><updated>2014-12-12T07:57:00+01:00</updated><author><name>Martin Zehetmayer</name></author><id>tag:shellpflanzerl.github.io,2014-12-12:upgrade-to-fedora-21.html</id><summary type="html">&lt;p&gt;Most of you already read it - Fedora 21 is out in the wild and ready to be installed. 
The main difference is that there are flavours of Fedora: Workstation, Server and Cloud. 
They are different in the number of packages installed - for example on the Workstation
installation there will be (of course) a graphical interface which will not appear on 
the server and the much smaller cloud flavour and in the default configuration of the 
systems (firewalld rules, for example)&lt;/p&gt;
&lt;p&gt;Coming from Fedora 20 I gave it a try on day 1 of the release to upgrade my Notebook: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; fedup --network &lt;span class="m"&gt;21&lt;/span&gt; --product workstation 
&lt;span class="go"&gt;[... download ... update kernel ... ]&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; reboot
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Surprisingly the upgrade ran without errors. Being a burnt child from the last updates
I was sceptical if this works out - but hey, no risk no fun :-) &lt;/p&gt;
&lt;p&gt;After that I was brave enough to update my NAS too: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; fedup --network &lt;span class="m"&gt;21&lt;/span&gt; --product server 
&lt;span class="go"&gt;[... download ... update kernel ... ]&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; reboot
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Again it worked seamlessly.&lt;/p&gt;
&lt;p&gt;So all I can say is: Good work, &lt;a href="https://www.fedoraproject.org"&gt;Fedoraproject&lt;/a&gt; ! Well done! &lt;/p&gt;</summary><category term="Linux"></category></entry><entry><title>Prevent systems from running fsck on boot</title><link href="https://shellpflanzerl.github.io/prevent-systems-from-running-fsck-on-boot.html" rel="alternate"></link><updated>2014-12-08T11:00:00+01:00</updated><author><name>Martin Zehetmayer</name></author><id>tag:shellpflanzerl.github.io,2014-12-08:prevent-systems-from-running-fsck-on-boot.html</id><summary type="html">&lt;p&gt;In some situation the fsck of a filesystem after a system reboot could be disastrous -
for example if you are just migrating a productive server with a very large filesystem on it.&lt;/p&gt;
&lt;p&gt;How can this be achieved?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Check if the files /forcefsck or /.autofsck exists in your root directory. Delete them. &lt;/li&gt;
&lt;li&gt;Set the fs_passno in your /etc/fstab entry to zero (This is the last value in a line)&lt;/li&gt;
&lt;li&gt;If you are using a system with systemd you can simply add 'fsck=skip' to your boot options.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To check if a system is running a fsck on the next reboot you can check if the mount count or the 
mount interval is exceeding the configured values.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; dumpe2fs -h /dev/mapper/my_vol_to_check 
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;span class="go"&gt;Mount count:              8&lt;/span&gt;
&lt;span class="go"&gt;Maximum mount count:      28&lt;/span&gt;
&lt;span class="go"&gt;Check interval:           15552000 (6 months)&lt;/span&gt;
&lt;span class="go"&gt;Next check after:         Wed Jan  7 12:18:30 2015&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you want to disable these checks you use tune2fs: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;tune2fs -c0 -i0 /dev/mapper/my_vol_to_check&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Linux"></category></entry><entry><title>Create A Empty git Branch</title><link href="https://shellpflanzerl.github.io/create-a-empty-git-branch.html" rel="alternate"></link><updated>2014-12-03T22:00:00+01:00</updated><author><name>Georg Vogetseder</name></author><id>tag:shellpflanzerl.github.io,2014-12-03:create-a-empty-git-branch.html</id><summary type="html">&lt;p&gt;If you want to create a new branch without any commit history:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git checkout --orphan &amp;lt;branch_name&amp;gt;
git rm -r .
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;git rm -r&lt;/code&gt; removes the files copied from the origin branch.&lt;/p&gt;</summary></entry></feed>